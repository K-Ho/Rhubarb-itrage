import BigNumber from 'bignumber.js';
import { SignedOrder, Order } from '../types';
import { TokenWrapper } from '../contract_wrappers/token_wrapper';
import { ExchangeWrapper } from '../contract_wrappers/exchange_wrapper';
import { ExchangeTransferSimulator } from './exchange_transfer_simulator';
export declare class OrderValidationUtils {
    private tokenWrapper;
    private exchangeWrapper;
    constructor(tokenWrapper: TokenWrapper, exchangeWrapper: ExchangeWrapper);
    validateOrderFillableOrThrowAsync(exchangeTradeEmulator: ExchangeTransferSimulator, signedOrder: SignedOrder, zrxTokenAddress: string, expectedFillTakerTokenAmount?: BigNumber): Promise<void>;
    validateFillOrderThrowIfInvalidAsync(exchangeTradeEmulator: ExchangeTransferSimulator, signedOrder: SignedOrder, fillTakerTokenAmount: BigNumber, takerAddress: string, zrxTokenAddress: string): Promise<BigNumber>;
    validateFillOrKillOrderThrowIfInvalidAsync(exchangeTradeEmulator: ExchangeTransferSimulator, signedOrder: SignedOrder, fillTakerTokenAmount: BigNumber, takerAddress: string, zrxTokenAddress: string): Promise<void>;
    validateCancelOrderThrowIfInvalidAsync(order: Order, cancelTakerTokenAmount: BigNumber, unavailableTakerTokenAmount: BigNumber): Promise<void>;
    validateFillOrderBalancesAllowancesThrowIfInvalidAsync(exchangeTradeEmulator: ExchangeTransferSimulator, signedOrder: SignedOrder, fillTakerTokenAmount: BigNumber, senderAddress: string, zrxTokenAddress: string): Promise<void>;
    private validateRemainingFillAmountNotZeroOrThrow(takerTokenAmount, unavailableTakerTokenAmount);
    private validateOrderNotExpiredOrThrow(expirationUnixTimestampSec);
    private getPartialAmount(numerator, denominator, target);
}
