"use strict";
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
var __generator = (this && this.__generator) || function (thisArg, body) {
    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;
    return g = { next: verb(0), "throw": verb(1), "return": verb(2) }, typeof Symbol === "function" && (g[Symbol.iterator] = function() { return this; }), g;
    function verb(n) { return function (v) { return step([n, v]); }; }
    function step(op) {
        if (f) throw new TypeError("Generator is already executing.");
        while (_) try {
            if (f = 1, y && (t = y[op[0] & 2 ? "return" : op[0] ? "throw" : "next"]) && !(t = t.call(y, op[1])).done) return t;
            if (y = 0, t) op = [0, t.value];
            switch (op[0]) {
                case 0: case 1: t = op; break;
                case 4: _.label++; return { value: op[1], done: false };
                case 5: _.label++; y = op[1]; op = [0]; continue;
                case 7: op = _.ops.pop(); _.trys.pop(); continue;
                default:
                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }
                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }
                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }
                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }
                    if (t[2]) _.ops.pop();
                    _.trys.pop(); continue;
            }
            op = body.call(thisArg, _);
        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }
        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };
    }
};
var _this = this;
Object.defineProperty(exports, "__esModule", { value: true });
require("mocha");
var chai = require("chai");
var _ = require("lodash");
var bignumber_js_1 = require("bignumber.js");
var chai_setup_1 = require("./utils/chai_setup");
var web3_factory_1 = require("./utils/web3_factory");
var src_1 = require("../src");
var token_utils_1 = require("./utils/token_utils");
var fill_scenarios_1 = require("./utils/fill_scenarios");
var blockchain_lifecycle_1 = require("./utils/blockchain_lifecycle");
var report_callback_errors_1 = require("./utils/report_callback_errors");
var TIMEOUT_MS = 150;
chai_setup_1.chaiSetup.configure();
var expect = chai.expect;
var blockchainLifecycle = new blockchain_lifecycle_1.BlockchainLifecycle();
describe('OrderStateWatcher', function () {
    var web3;
    var zeroEx;
    var tokens;
    var tokenUtils;
    var fillScenarios;
    var userAddresses;
    var zrxTokenAddress;
    var exchangeContractAddress;
    var makerToken;
    var takerToken;
    var maker;
    var taker;
    var web3Wrapper;
    var signedOrder;
    var fillableAmount = src_1.ZeroEx.toBaseUnitAmount(new bignumber_js_1.default(5), 18);
    before(function () { return __awaiter(_this, void 0, void 0, function () {
        var _a;
        return __generator(this, function (_b) {
            switch (_b.label) {
                case 0:
                    web3 = web3_factory_1.web3Factory.create();
                    zeroEx = new src_1.ZeroEx(web3.currentProvider);
                    return [4 /*yield*/, zeroEx.exchange.getContractAddressAsync()];
                case 1:
                    exchangeContractAddress = _b.sent();
                    return [4 /*yield*/, zeroEx.getAvailableAddressesAsync()];
                case 2:
                    userAddresses = _b.sent();
                    maker = userAddresses[1], taker = userAddresses[2];
                    return [4 /*yield*/, zeroEx.tokenRegistry.getTokensAsync()];
                case 3:
                    tokens = _b.sent();
                    tokenUtils = new token_utils_1.TokenUtils(tokens);
                    zrxTokenAddress = tokenUtils.getProtocolTokenOrThrow().address;
                    fillScenarios = new fill_scenarios_1.FillScenarios(zeroEx, userAddresses, tokens, zrxTokenAddress, exchangeContractAddress);
                    _a = tokenUtils.getNonProtocolTokens(), makerToken = _a[0], takerToken = _a[1];
                    web3Wrapper = zeroEx._web3Wrapper;
                    return [2 /*return*/];
            }
        });
    }); });
    beforeEach(function () { return __awaiter(_this, void 0, void 0, function () {
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, blockchainLifecycle.startAsync()];
                case 1:
                    _a.sent();
                    return [2 /*return*/];
            }
        });
    }); });
    afterEach(function () { return __awaiter(_this, void 0, void 0, function () {
        return __generator(this, function (_a) {
            switch (_a.label) {
                case 0: return [4 /*yield*/, blockchainLifecycle.revertAsync()];
                case 1:
                    _a.sent();
                    return [2 /*return*/];
            }
        });
    }); });
    describe('#removeOrder', function () { return __awaiter(_this, void 0, void 0, function () {
        var _this = this;
        return __generator(this, function (_a) {
            it('should successfully remove existing order', function () { return __awaiter(_this, void 0, void 0, function () {
                var orderHash, dependentOrderHashes, _a, _b;
                return __generator(this, function (_c) {
                    switch (_c.label) {
                        case 0: return [4 /*yield*/, fillScenarios.createFillableSignedOrderAsync(makerToken.address, takerToken.address, maker, taker, fillableAmount)];
                        case 1:
                            signedOrder = _c.sent();
                            orderHash = src_1.ZeroEx.getOrderHashHex(signedOrder);
                            return [4 /*yield*/, zeroEx.orderStateWatcher.addOrderAsync(signedOrder)];
                        case 2:
                            _c.sent();
                            expect(zeroEx.orderStateWatcher._orderByOrderHash).to.include((_a = {},
                                _a[orderHash] = signedOrder,
                                _a));
                            dependentOrderHashes = zeroEx.orderStateWatcher._dependentOrderHashes;
                            expect(dependentOrderHashes[signedOrder.maker][signedOrder.makerTokenAddress]).to.have.keys(orderHash);
                            return [4 /*yield*/, zeroEx.orderStateWatcher.removeOrderAsync(orderHash)];
                        case 3:
                            _c.sent();
                            expect(zeroEx.orderStateWatcher._orderByOrderHash).to.not.include((_b = {},
                                _b[orderHash] = signedOrder,
                                _b));
                            dependentOrderHashes = zeroEx.orderStateWatcher._dependentOrderHashes;
                            expect(dependentOrderHashes[signedOrder.maker]).to.be.undefined();
                            return [2 /*return*/];
                    }
                });
            }); });
            it('should no-op when removing a non-existing order', function () { return __awaiter(_this, void 0, void 0, function () {
                var orderHash, nonExistentOrderHash;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0: return [4 /*yield*/, fillScenarios.createFillableSignedOrderAsync(makerToken.address, takerToken.address, maker, taker, fillableAmount)];
                        case 1:
                            signedOrder = _a.sent();
                            orderHash = src_1.ZeroEx.getOrderHashHex(signedOrder);
                            nonExistentOrderHash = "0x" + orderHash.substr(2).split('').reverse().join('');
                            return [4 /*yield*/, zeroEx.orderStateWatcher.removeOrderAsync(nonExistentOrderHash)];
                        case 2:
                            _a.sent();
                            return [2 /*return*/];
                    }
                });
            }); });
            return [2 /*return*/];
        });
    }); });
    describe('#subscribe', function () { return __awaiter(_this, void 0, void 0, function () {
        var _this = this;
        return __generator(this, function (_a) {
            afterEach(function () { return __awaiter(_this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    zeroEx.orderStateWatcher.unsubscribe();
                    return [2 /*return*/];
                });
            }); });
            it('should fail when trying to subscribe twice', function () { return __awaiter(_this, void 0, void 0, function () {
                return __generator(this, function (_a) {
                    zeroEx.orderStateWatcher.subscribe(_.noop);
                    expect(function () { return zeroEx.orderStateWatcher.subscribe(_.noop); })
                        .to.throw(src_1.ZeroExError.SubscriptionAlreadyPresent);
                    return [2 /*return*/];
                });
            }); });
            return [2 /*return*/];
        });
    }); });
    describe('tests with cleanup', function () { return __awaiter(_this, void 0, void 0, function () {
        var _this = this;
        return __generator(this, function (_a) {
            afterEach(function () { return __awaiter(_this, void 0, void 0, function () {
                var orderHash;
                return __generator(this, function (_a) {
                    switch (_a.label) {
                        case 0:
                            zeroEx.orderStateWatcher.unsubscribe();
                            orderHash = src_1.ZeroEx.getOrderHashHex(signedOrder);
                            return [4 /*yield*/, zeroEx.orderStateWatcher.removeOrderAsync(orderHash)];
                        case 1:
                            _a.sent();
                            return [2 /*return*/];
                    }
                });
            }); });
            it('should emit orderStateInvalid when maker allowance set to 0 for watched order', function (done) {
                (function () { return __awaiter(_this, void 0, void 0, function () {
                    var orderHash, callback;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, fillScenarios.createFillableSignedOrderAsync(makerToken.address, takerToken.address, maker, taker, fillableAmount)];
                            case 1:
                                signedOrder = _a.sent();
                                orderHash = src_1.ZeroEx.getOrderHashHex(signedOrder);
                                return [4 /*yield*/, zeroEx.orderStateWatcher.addOrderAsync(signedOrder)];
                            case 2:
                                _a.sent();
                                callback = report_callback_errors_1.reportCallbackErrors(done)(function (orderState) {
                                    expect(orderState.isValid).to.be.false();
                                    var invalidOrderState = orderState;
                                    expect(invalidOrderState.orderHash).to.be.equal(orderHash);
                                    expect(invalidOrderState.error).to.be.equal(src_1.ExchangeContractErrs.InsufficientMakerAllowance);
                                    done();
                                });
                                zeroEx.orderStateWatcher.subscribe(callback);
                                return [4 /*yield*/, zeroEx.token.setProxyAllowanceAsync(makerToken.address, maker, new bignumber_js_1.default(0))];
                            case 3:
                                _a.sent();
                                return [2 /*return*/];
                        }
                    });
                }); })().catch(done);
            });
            it('should not emit an orderState event when irrelevant Transfer event received', function (done) {
                (function () { return __awaiter(_this, void 0, void 0, function () {
                    var orderHash, callback, notTheMaker, anyRecipient, transferAmount, notTheMakerBalance;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, fillScenarios.createFillableSignedOrderAsync(makerToken.address, takerToken.address, maker, taker, fillableAmount)];
                            case 1:
                                signedOrder = _a.sent();
                                orderHash = src_1.ZeroEx.getOrderHashHex(signedOrder);
                                return [4 /*yield*/, zeroEx.orderStateWatcher.addOrderAsync(signedOrder)];
                            case 2:
                                _a.sent();
                                callback = report_callback_errors_1.reportCallbackErrors(done)(function (orderState) {
                                    throw new Error('OrderState callback fired for irrelevant order');
                                });
                                zeroEx.orderStateWatcher.subscribe(callback);
                                notTheMaker = userAddresses[0];
                                anyRecipient = taker;
                                transferAmount = new bignumber_js_1.default(2);
                                return [4 /*yield*/, zeroEx.token.getBalanceAsync(makerToken.address, notTheMaker)];
                            case 3:
                                notTheMakerBalance = _a.sent();
                                return [4 /*yield*/, zeroEx.token.transferAsync(makerToken.address, notTheMaker, anyRecipient, transferAmount)];
                            case 4:
                                _a.sent();
                                setTimeout(function () {
                                    done();
                                }, TIMEOUT_MS);
                                return [2 /*return*/];
                        }
                    });
                }); })().catch(done);
            });
            it('should emit orderStateInvalid when maker moves balance backing watched order', function (done) {
                (function () { return __awaiter(_this, void 0, void 0, function () {
                    var orderHash, callback, anyRecipient, makerBalance;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, fillScenarios.createFillableSignedOrderAsync(makerToken.address, takerToken.address, maker, taker, fillableAmount)];
                            case 1:
                                signedOrder = _a.sent();
                                orderHash = src_1.ZeroEx.getOrderHashHex(signedOrder);
                                return [4 /*yield*/, zeroEx.orderStateWatcher.addOrderAsync(signedOrder)];
                            case 2:
                                _a.sent();
                                callback = report_callback_errors_1.reportCallbackErrors(done)(function (orderState) {
                                    expect(orderState.isValid).to.be.false();
                                    var invalidOrderState = orderState;
                                    expect(invalidOrderState.orderHash).to.be.equal(orderHash);
                                    expect(invalidOrderState.error).to.be.equal(src_1.ExchangeContractErrs.InsufficientMakerBalance);
                                    done();
                                });
                                zeroEx.orderStateWatcher.subscribe(callback);
                                anyRecipient = taker;
                                return [4 /*yield*/, zeroEx.token.getBalanceAsync(makerToken.address, maker)];
                            case 3:
                                makerBalance = _a.sent();
                                return [4 /*yield*/, zeroEx.token.transferAsync(makerToken.address, maker, anyRecipient, makerBalance)];
                            case 4:
                                _a.sent();
                                return [2 /*return*/];
                        }
                    });
                }); })().catch(done);
            });
            it('should emit orderStateInvalid when watched order fully filled', function (done) {
                (function () { return __awaiter(_this, void 0, void 0, function () {
                    var orderHash, eventCount, callback, shouldThrowOnInsufficientBalanceOrAllowance;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, fillScenarios.createFillableSignedOrderAsync(makerToken.address, takerToken.address, maker, taker, fillableAmount)];
                            case 1:
                                signedOrder = _a.sent();
                                orderHash = src_1.ZeroEx.getOrderHashHex(signedOrder);
                                return [4 /*yield*/, zeroEx.orderStateWatcher.addOrderAsync(signedOrder)];
                            case 2:
                                _a.sent();
                                eventCount = 0;
                                callback = report_callback_errors_1.reportCallbackErrors(done)(function (orderState) {
                                    eventCount++;
                                    expect(orderState.isValid).to.be.false();
                                    var invalidOrderState = orderState;
                                    expect(invalidOrderState.orderHash).to.be.equal(orderHash);
                                    expect(invalidOrderState.error).to.be.equal(src_1.ExchangeContractErrs.OrderRemainingFillAmountZero);
                                    if (eventCount === 2) {
                                        done();
                                    }
                                });
                                zeroEx.orderStateWatcher.subscribe(callback);
                                shouldThrowOnInsufficientBalanceOrAllowance = true;
                                return [4 /*yield*/, zeroEx.exchange.fillOrderAsync(signedOrder, fillableAmount, shouldThrowOnInsufficientBalanceOrAllowance, taker)];
                            case 3:
                                _a.sent();
                                return [2 /*return*/];
                        }
                    });
                }); })().catch(done);
            });
            it('should emit orderStateValid when watched order partially filled', function (done) {
                (function () { return __awaiter(_this, void 0, void 0, function () {
                    var makerBalance, takerBalance, fillAmountInBaseUnits, orderHash, eventCount, callback, shouldThrowOnInsufficientBalanceOrAllowance;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, fillScenarios.createFillableSignedOrderAsync(makerToken.address, takerToken.address, maker, taker, fillableAmount)];
                            case 1:
                                signedOrder = _a.sent();
                                return [4 /*yield*/, zeroEx.token.getBalanceAsync(makerToken.address, maker)];
                            case 2:
                                makerBalance = _a.sent();
                                return [4 /*yield*/, zeroEx.token.getBalanceAsync(makerToken.address, taker)];
                            case 3:
                                takerBalance = _a.sent();
                                fillAmountInBaseUnits = new bignumber_js_1.default(2);
                                orderHash = src_1.ZeroEx.getOrderHashHex(signedOrder);
                                return [4 /*yield*/, zeroEx.orderStateWatcher.addOrderAsync(signedOrder)];
                            case 4:
                                _a.sent();
                                eventCount = 0;
                                callback = report_callback_errors_1.reportCallbackErrors(done)(function (orderState) {
                                    eventCount++;
                                    expect(orderState.isValid).to.be.true();
                                    var validOrderState = orderState;
                                    expect(validOrderState.orderHash).to.be.equal(orderHash);
                                    var orderRelevantState = validOrderState.orderRelevantState;
                                    var remainingMakerBalance = makerBalance.sub(fillAmountInBaseUnits);
                                    var remainingFillable = fillableAmount.minus(fillAmountInBaseUnits);
                                    expect(orderRelevantState.remainingFillableMakerTokenAmount).to.be.bignumber.equal(remainingFillable);
                                    expect(orderRelevantState.remainingFillableTakerTokenAmount).to.be.bignumber.equal(remainingFillable);
                                    expect(orderRelevantState.makerBalance).to.be.bignumber.equal(remainingMakerBalance);
                                    if (eventCount === 2) {
                                        done();
                                    }
                                });
                                zeroEx.orderStateWatcher.subscribe(callback);
                                shouldThrowOnInsufficientBalanceOrAllowance = true;
                                return [4 /*yield*/, zeroEx.exchange.fillOrderAsync(signedOrder, fillAmountInBaseUnits, shouldThrowOnInsufficientBalanceOrAllowance, taker)];
                            case 5:
                                _a.sent();
                                return [2 /*return*/];
                        }
                    });
                }); })().catch(done);
            });
            it('should trigger the callback when orders backing ZRX allowance changes', function (done) {
                (function () { return __awaiter(_this, void 0, void 0, function () {
                    var makerFee, takerFee, orderHash, callback;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                makerFee = src_1.ZeroEx.toBaseUnitAmount(new bignumber_js_1.default(2), 18);
                                takerFee = src_1.ZeroEx.toBaseUnitAmount(new bignumber_js_1.default(0), 18);
                                return [4 /*yield*/, fillScenarios.createFillableSignedOrderWithFeesAsync(makerToken.address, takerToken.address, makerFee, takerFee, maker, taker, fillableAmount, taker)];
                            case 1:
                                signedOrder = _a.sent();
                                orderHash = src_1.ZeroEx.getOrderHashHex(signedOrder);
                                return [4 /*yield*/, zeroEx.orderStateWatcher.addOrderAsync(signedOrder)];
                            case 2:
                                _a.sent();
                                callback = report_callback_errors_1.reportCallbackErrors(done)(function (orderState) {
                                    done();
                                });
                                zeroEx.orderStateWatcher.subscribe(callback);
                                return [4 /*yield*/, zeroEx.token.setProxyAllowanceAsync(zrxTokenAddress, maker, new bignumber_js_1.default(0))];
                            case 3:
                                _a.sent();
                                return [2 /*return*/];
                        }
                    });
                }); })().catch(done);
            });
            describe('remainingFillable(M|T)akerTokenAmount', function () {
                it('should calculate correct remaining fillable', function (done) {
                    (function () { return __awaiter(_this, void 0, void 0, function () {
                        var takerFillableAmount, makerFillableAmount, makerBalance, takerBalance, fillAmountInBaseUnits, orderHash, eventCount, callback, shouldThrowOnInsufficientBalanceOrAllowance;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0:
                                    takerFillableAmount = src_1.ZeroEx.toBaseUnitAmount(new bignumber_js_1.default(10), 18);
                                    makerFillableAmount = src_1.ZeroEx.toBaseUnitAmount(new bignumber_js_1.default(20), 18);
                                    return [4 /*yield*/, fillScenarios.createAsymmetricFillableSignedOrderAsync(makerToken.address, takerToken.address, maker, taker, makerFillableAmount, takerFillableAmount)];
                                case 1:
                                    signedOrder = _a.sent();
                                    return [4 /*yield*/, zeroEx.token.getBalanceAsync(makerToken.address, maker)];
                                case 2:
                                    makerBalance = _a.sent();
                                    return [4 /*yield*/, zeroEx.token.getBalanceAsync(makerToken.address, taker)];
                                case 3:
                                    takerBalance = _a.sent();
                                    fillAmountInBaseUnits = src_1.ZeroEx.toBaseUnitAmount(new bignumber_js_1.default(2), 18);
                                    orderHash = src_1.ZeroEx.getOrderHashHex(signedOrder);
                                    return [4 /*yield*/, zeroEx.orderStateWatcher.addOrderAsync(signedOrder)];
                                case 4:
                                    _a.sent();
                                    eventCount = 0;
                                    callback = report_callback_errors_1.reportCallbackErrors(done)(function (orderState) {
                                        eventCount++;
                                        expect(orderState.isValid).to.be.true();
                                        var validOrderState = orderState;
                                        expect(validOrderState.orderHash).to.be.equal(orderHash);
                                        var orderRelevantState = validOrderState.orderRelevantState;
                                        expect(orderRelevantState.remainingFillableMakerTokenAmount).to.be.bignumber.equal(src_1.ZeroEx.toBaseUnitAmount(new bignumber_js_1.default(16), 18));
                                        expect(orderRelevantState.remainingFillableTakerTokenAmount).to.be.bignumber.equal(src_1.ZeroEx.toBaseUnitAmount(new bignumber_js_1.default(8), 18));
                                        if (eventCount === 2) {
                                            done();
                                        }
                                    });
                                    zeroEx.orderStateWatcher.subscribe(callback);
                                    shouldThrowOnInsufficientBalanceOrAllowance = true;
                                    return [4 /*yield*/, zeroEx.exchange.fillOrderAsync(signedOrder, fillAmountInBaseUnits, shouldThrowOnInsufficientBalanceOrAllowance, taker)];
                                case 5:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    }); })().catch(done);
                });
                it('should equal approved amount when approved amount is lowest', function (done) {
                    (function () { return __awaiter(_this, void 0, void 0, function () {
                        var makerBalance, changedMakerApprovalAmount, callback;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, fillScenarios.createFillableSignedOrderAsync(makerToken.address, takerToken.address, maker, taker, fillableAmount)];
                                case 1:
                                    signedOrder = _a.sent();
                                    return [4 /*yield*/, zeroEx.token.getBalanceAsync(makerToken.address, maker)];
                                case 2:
                                    makerBalance = _a.sent();
                                    changedMakerApprovalAmount = src_1.ZeroEx.toBaseUnitAmount(new bignumber_js_1.default(3), 18);
                                    return [4 /*yield*/, zeroEx.orderStateWatcher.addOrderAsync(signedOrder)];
                                case 3:
                                    _a.sent();
                                    callback = report_callback_errors_1.reportCallbackErrors(done)(function (orderState) {
                                        var validOrderState = orderState;
                                        var orderRelevantState = validOrderState.orderRelevantState;
                                        expect(orderRelevantState.remainingFillableMakerTokenAmount).to.be.bignumber.equal(changedMakerApprovalAmount);
                                        expect(orderRelevantState.remainingFillableTakerTokenAmount).to.be.bignumber.equal(changedMakerApprovalAmount);
                                        done();
                                    });
                                    zeroEx.orderStateWatcher.subscribe(callback);
                                    return [4 /*yield*/, zeroEx.token.setProxyAllowanceAsync(makerToken.address, maker, changedMakerApprovalAmount)];
                                case 4:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    }); })().catch(done);
                });
                it('should equal balance amount when balance amount is lowest', function (done) {
                    (function () { return __awaiter(_this, void 0, void 0, function () {
                        var makerBalance, remainingAmount, transferAmount, callback;
                        return __generator(this, function (_a) {
                            switch (_a.label) {
                                case 0: return [4 /*yield*/, fillScenarios.createFillableSignedOrderAsync(makerToken.address, takerToken.address, maker, taker, fillableAmount)];
                                case 1:
                                    signedOrder = _a.sent();
                                    return [4 /*yield*/, zeroEx.token.getBalanceAsync(makerToken.address, maker)];
                                case 2:
                                    makerBalance = _a.sent();
                                    remainingAmount = src_1.ZeroEx.toBaseUnitAmount(new bignumber_js_1.default(1), 18);
                                    transferAmount = makerBalance.sub(remainingAmount);
                                    return [4 /*yield*/, zeroEx.orderStateWatcher.addOrderAsync(signedOrder)];
                                case 3:
                                    _a.sent();
                                    callback = report_callback_errors_1.reportCallbackErrors(done)(function (orderState) {
                                        var validOrderState = orderState;
                                        var orderRelevantState = validOrderState.orderRelevantState;
                                        expect(orderRelevantState.remainingFillableMakerTokenAmount).to.be.bignumber.equal(remainingAmount);
                                        expect(orderRelevantState.remainingFillableTakerTokenAmount).to.be.bignumber.equal(remainingAmount);
                                        done();
                                    });
                                    zeroEx.orderStateWatcher.subscribe(callback);
                                    return [4 /*yield*/, zeroEx.token.transferAsync(makerToken.address, maker, src_1.ZeroEx.NULL_ADDRESS, transferAmount)];
                                case 4:
                                    _a.sent();
                                    return [2 /*return*/];
                            }
                        });
                    }); })().catch(done);
                });
            });
            it('should emit orderStateInvalid when watched order cancelled', function (done) {
                (function () { return __awaiter(_this, void 0, void 0, function () {
                    var orderHash, callback, shouldThrowOnInsufficientBalanceOrAllowance;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, fillScenarios.createFillableSignedOrderAsync(makerToken.address, takerToken.address, maker, taker, fillableAmount)];
                            case 1:
                                signedOrder = _a.sent();
                                orderHash = src_1.ZeroEx.getOrderHashHex(signedOrder);
                                return [4 /*yield*/, zeroEx.orderStateWatcher.addOrderAsync(signedOrder)];
                            case 2:
                                _a.sent();
                                callback = report_callback_errors_1.reportCallbackErrors(done)(function (orderState) {
                                    expect(orderState.isValid).to.be.false();
                                    var invalidOrderState = orderState;
                                    expect(invalidOrderState.orderHash).to.be.equal(orderHash);
                                    expect(invalidOrderState.error).to.be.equal(src_1.ExchangeContractErrs.OrderRemainingFillAmountZero);
                                    done();
                                });
                                zeroEx.orderStateWatcher.subscribe(callback);
                                shouldThrowOnInsufficientBalanceOrAllowance = true;
                                return [4 /*yield*/, zeroEx.exchange.cancelOrderAsync(signedOrder, fillableAmount)];
                            case 3:
                                _a.sent();
                                return [2 /*return*/];
                        }
                    });
                }); })().catch(done);
            });
            it('should emit orderStateInvalid when within rounding error range', function (done) {
                (function () { return __awaiter(_this, void 0, void 0, function () {
                    var remainingFillableAmountInBaseUnits, orderHash, callback;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0:
                                remainingFillableAmountInBaseUnits = new bignumber_js_1.default(100);
                                return [4 /*yield*/, fillScenarios.createFillableSignedOrderAsync(makerToken.address, takerToken.address, maker, taker, fillableAmount)];
                            case 1:
                                signedOrder = _a.sent();
                                orderHash = src_1.ZeroEx.getOrderHashHex(signedOrder);
                                return [4 /*yield*/, zeroEx.orderStateWatcher.addOrderAsync(signedOrder)];
                            case 2:
                                _a.sent();
                                callback = report_callback_errors_1.reportCallbackErrors(done)(function (orderState) {
                                    expect(orderState.isValid).to.be.false();
                                    var invalidOrderState = orderState;
                                    expect(invalidOrderState.orderHash).to.be.equal(orderHash);
                                    expect(invalidOrderState.error).to.be.equal(src_1.ExchangeContractErrs.OrderFillRoundingError);
                                    done();
                                });
                                zeroEx.orderStateWatcher.subscribe(callback);
                                return [4 /*yield*/, zeroEx.exchange.cancelOrderAsync(signedOrder, fillableAmount.minus(remainingFillableAmountInBaseUnits))];
                            case 3:
                                _a.sent();
                                return [2 /*return*/];
                        }
                    });
                }); })().catch(done);
            });
            it('should emit orderStateValid when watched order partially cancelled', function (done) {
                (function () { return __awaiter(_this, void 0, void 0, function () {
                    var makerBalance, takerBalance, cancelAmountInBaseUnits, orderHash, callback;
                    return __generator(this, function (_a) {
                        switch (_a.label) {
                            case 0: return [4 /*yield*/, fillScenarios.createFillableSignedOrderAsync(makerToken.address, takerToken.address, maker, taker, fillableAmount)];
                            case 1:
                                signedOrder = _a.sent();
                                return [4 /*yield*/, zeroEx.token.getBalanceAsync(makerToken.address, maker)];
                            case 2:
                                makerBalance = _a.sent();
                                return [4 /*yield*/, zeroEx.token.getBalanceAsync(makerToken.address, taker)];
                            case 3:
                                takerBalance = _a.sent();
                                cancelAmountInBaseUnits = new bignumber_js_1.default(2);
                                orderHash = src_1.ZeroEx.getOrderHashHex(signedOrder);
                                return [4 /*yield*/, zeroEx.orderStateWatcher.addOrderAsync(signedOrder)];
                            case 4:
                                _a.sent();
                                callback = report_callback_errors_1.reportCallbackErrors(done)(function (orderState) {
                                    expect(orderState.isValid).to.be.true();
                                    var validOrderState = orderState;
                                    expect(validOrderState.orderHash).to.be.equal(orderHash);
                                    var orderRelevantState = validOrderState.orderRelevantState;
                                    expect(orderRelevantState.cancelledTakerTokenAmount).to.be.bignumber.equal(cancelAmountInBaseUnits);
                                    done();
                                });
                                zeroEx.orderStateWatcher.subscribe(callback);
                                return [4 /*yield*/, zeroEx.exchange.cancelOrderAsync(signedOrder, cancelAmountInBaseUnits)];
                            case 5:
                                _a.sent();
                                return [2 /*return*/];
                        }
                    });
                }); })().catch(done);
            });
            return [2 /*return*/];
        });
    }); });
});
//# sourceMappingURL=order_state_watcher_test.js.map